(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ngx-intl', ['exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global['ngx-intl'] = {}, global.ng.core, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, rxjs, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NGX_INTL_DEFAULT_LOCALE = new core.InjectionToken('ngx.intl.default.locale');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @author Abdel El-medny
     *
     * This service will be the backbone of the intl number and date pipe
     */
    var IntlService = /** @class */ (function () {
        function IntlService(defaultLocale) {
            this.defaultLocale = defaultLocale;
            this.locale$ = new rxjs.BehaviorSubject(this.defaultLocale);
        }
        /**
         * @param {?} locale
         * @return {?}
         */
        IntlService.prototype.updateLocale = /**
         * @param {?} locale
         * @return {?}
         */
        function (locale) {
            this.locale$.next(locale);
        };
        /**
         * @return {?}
         */
        IntlService.prototype.getLocale$ = /**
         * @return {?}
         */
        function () {
            return this.locale$;
        };
        IntlService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        IntlService.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [NGX_INTL_DEFAULT_LOCALE,] }] }
        ]; };
        /** @nocollapse */ IntlService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function IntlService_Factory() { return new IntlService(core.ɵɵinject(NGX_INTL_DEFAULT_LOCALE)); }, token: IntlService, providedIn: "root" });
        return IntlService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @author Abdel El-medny
     *
     * Shows dates based on the Intl API
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     */
    var IntlDatePipe = /** @class */ (function () {
        function IntlDatePipe(changeDetectorRef, $internationalisation) {
            var _this = this;
            this.changeDetectorRef = changeDetectorRef;
            this.$internationalisation = $internationalisation;
            this.lastOutput = null;
            this.lastInput = [null, null];
            this.stop$ = new rxjs.Subject();
            // If the locale changes, we will take the last inputs we were given, will re-calc the output and trigger CD
            //
            this.$internationalisation.getLocale$().pipe(operators.takeUntil(this.stop$), operators.skip(1))
                .subscribe((/**
             * @param {?} locale
             * @return {?}
             */
            function (locale) {
                var _a = __read(_this.lastInput, 2), lastValue = _a[0], lastOpts = _a[1];
                /** @type {?} */
                var dateObject = (lastValue && typeof lastValue === 'string') ? new Date((/** @type {?} */ (lastValue))) : (/** @type {?} */ (lastValue));
                _this.lastOutput = new Intl.DateTimeFormat(locale, lastOpts).format(dateObject);
                _this.changeDetectorRef.markForCheck();
            }));
        }
        /**
         * @param {?} value
         * @param {?=} opts
         * @return {?}
         */
        IntlDatePipe.prototype.transform = /**
         * @param {?} value
         * @param {?=} opts
         * @return {?}
         */
        function (value, opts) {
            // If the input hasn't changed, we will send back the last calculated value
            //
            if (this.lastInput.toString() === value.toString()) {
                return this.lastOutput;
            }
            // Storing this for later usage incase locale changes
            //
            this.lastInput = [(/** @type {?} */ (arguments[0])), (/** @type {?} */ (arguments[1]))];
            /** @type {?} */
            var currentLocale = this.$internationalisation.getLocale$().value;
            /** @type {?} */
            var dateObject = typeof value === 'string' ? new Date((/** @type {?} */ (value))) : (/** @type {?} */ (value));
            this.lastOutput = new Intl.DateTimeFormat(currentLocale, opts).format(dateObject);
            return this.lastOutput;
        };
        /**
         * @return {?}
         */
        IntlDatePipe.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.stop$.next();
        };
        IntlDatePipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'intlDate',
                        pure: false,
                    },] }
        ];
        /** @nocollapse */
        IntlDatePipe.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: IntlService }
        ]; };
        return IntlDatePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @author Abdel El-medny
     *
     * Shows numbers based on the Intl API
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat
     */
    var IntlNumberPipe = /** @class */ (function () {
        function IntlNumberPipe(changeDetectorRef, $intl) {
            var _this = this;
            this.changeDetectorRef = changeDetectorRef;
            this.$intl = $intl;
            this.lastOutput = null;
            this.lastInput = [null, null];
            this.stop$ = new rxjs.Subject();
            // If the locale changes, we will take the last inputs we were given, will re-calc the output and trigger CD
            //
            this.$intl.getLocale$().pipe(operators.takeUntil(this.stop$), operators.skip(1))
                .subscribe((/**
             * @param {?} locale
             * @return {?}
             */
            function (locale) {
                var _a = __read(_this.lastInput, 2), lastDate = _a[0], lastOpts = _a[1];
                _this.lastOutput = new Intl.NumberFormat(locale, lastOpts).format(lastDate);
                _this.changeDetectorRef.markForCheck();
            }));
        }
        /**
         * @param {?} value
         * @param {?=} opts
         * @return {?}
         */
        IntlNumberPipe.prototype.transform = /**
         * @param {?} value
         * @param {?=} opts
         * @return {?}
         */
        function (value, opts) {
            // If the input hasn't changed, we will send back the last calculated value
            //
            if (this.lastInput.toString() === value.toString()) {
                return this.lastOutput;
            }
            // Storing this for later usage incase locale changes
            //
            this.lastInput = [(/** @type {?} */ (arguments[0])), (/** @type {?} */ (arguments[1]))];
            /** @type {?} */
            var currentLocale = this.$intl.getLocale$().value;
            this.lastOutput = new Intl.NumberFormat(currentLocale, opts).format(value);
            return this.lastOutput;
        };
        /**
         * @return {?}
         */
        IntlNumberPipe.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.stop$.next();
        };
        IntlNumberPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'intlNumber',
                        pure: false,
                    },] }
        ];
        /** @nocollapse */
        IntlNumberPipe.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: IntlService }
        ]; };
        return IntlNumberPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxIntlModule = /** @class */ (function () {
        function NgxIntlModule() {
        }
        /**
         * @param {?} options
         * @return {?}
         */
        NgxIntlModule.forRoot = /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            return {
                ngModule: NgxIntlModule,
                providers: [
                    (/** @type {?} */ ({ provide: NGX_INTL_DEFAULT_LOCALE, useValue: options.defaultLocale })),
                ]
            };
        };
        NgxIntlModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [IntlDatePipe, IntlNumberPipe],
                        imports: [],
                        exports: [IntlDatePipe, IntlNumberPipe]
                    },] }
        ];
        return NgxIntlModule;
    }());

    exports.IntlService = IntlService;
    exports.NgxIntlModule = NgxIntlModule;
    exports.ɵa = NGX_INTL_DEFAULT_LOCALE;
    exports.ɵb = IntlDatePipe;
    exports.ɵc = IntlNumberPipe;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngx-intl.umd.js.map
