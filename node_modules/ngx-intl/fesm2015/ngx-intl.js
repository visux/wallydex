import { InjectionToken, Injectable, Inject, ɵɵdefineInjectable, ɵɵinject, Pipe, ChangeDetectorRef, NgModule } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil, skip } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NGX_INTL_DEFAULT_LOCALE = new InjectionToken('ngx.intl.default.locale');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @author Abdel El-medny
 *
 * This service will be the backbone of the intl number and date pipe
 */
class IntlService {
    /**
     * @param {?} defaultLocale
     */
    constructor(defaultLocale) {
        this.defaultLocale = defaultLocale;
        this.locale$ = new BehaviorSubject(this.defaultLocale);
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    updateLocale(locale) {
        this.locale$.next(locale);
    }
    /**
     * @return {?}
     */
    getLocale$() {
        return this.locale$;
    }
}
IntlService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
IntlService.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [NGX_INTL_DEFAULT_LOCALE,] }] }
];
/** @nocollapse */ IntlService.ngInjectableDef = ɵɵdefineInjectable({ factory: function IntlService_Factory() { return new IntlService(ɵɵinject(NGX_INTL_DEFAULT_LOCALE)); }, token: IntlService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @author Abdel El-medny
 *
 * Shows dates based on the Intl API
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
 */
class IntlDatePipe {
    /**
     * @param {?} changeDetectorRef
     * @param {?} $internationalisation
     */
    constructor(changeDetectorRef, $internationalisation) {
        this.changeDetectorRef = changeDetectorRef;
        this.$internationalisation = $internationalisation;
        this.lastOutput = null;
        this.lastInput = [null, null];
        this.stop$ = new Subject();
        // If the locale changes, we will take the last inputs we were given, will re-calc the output and trigger CD
        //
        this.$internationalisation.getLocale$().pipe(takeUntil(this.stop$), skip(1))
            .subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            const [lastValue, lastOpts] = this.lastInput;
            /** @type {?} */
            const dateObject = (lastValue && typeof lastValue === 'string') ? new Date((/** @type {?} */ (lastValue))) : (/** @type {?} */ (lastValue));
            this.lastOutput = new Intl.DateTimeFormat(locale, lastOpts).format(dateObject);
            this.changeDetectorRef.markForCheck();
        }));
    }
    /**
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    transform(value, opts) {
        // If the input hasn't changed, we will send back the last calculated value
        //
        if (this.lastInput.toString() === value.toString()) {
            return this.lastOutput;
        }
        // Storing this for later usage incase locale changes
        //
        this.lastInput = [(/** @type {?} */ (arguments[0])), (/** @type {?} */ (arguments[1]))];
        /** @type {?} */
        const currentLocale = this.$internationalisation.getLocale$().value;
        /** @type {?} */
        const dateObject = typeof value === 'string' ? new Date((/** @type {?} */ (value))) : (/** @type {?} */ (value));
        this.lastOutput = new Intl.DateTimeFormat(currentLocale, opts).format(dateObject);
        return this.lastOutput;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.stop$.next();
    }
}
IntlDatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'intlDate',
                pure: false,
            },] }
];
/** @nocollapse */
IntlDatePipe.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IntlService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @author Abdel El-medny
 *
 * Shows numbers based on the Intl API
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat
 */
class IntlNumberPipe {
    /**
     * @param {?} changeDetectorRef
     * @param {?} $intl
     */
    constructor(changeDetectorRef, $intl) {
        this.changeDetectorRef = changeDetectorRef;
        this.$intl = $intl;
        this.lastOutput = null;
        this.lastInput = [null, null];
        this.stop$ = new Subject();
        // If the locale changes, we will take the last inputs we were given, will re-calc the output and trigger CD
        //
        this.$intl.getLocale$().pipe(takeUntil(this.stop$), skip(1))
            .subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            const [lastDate, lastOpts] = this.lastInput;
            this.lastOutput = new Intl.NumberFormat(locale, lastOpts).format(lastDate);
            this.changeDetectorRef.markForCheck();
        }));
    }
    /**
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    transform(value, opts) {
        // If the input hasn't changed, we will send back the last calculated value
        //
        if (this.lastInput.toString() === value.toString()) {
            return this.lastOutput;
        }
        // Storing this for later usage incase locale changes
        //
        this.lastInput = [(/** @type {?} */ (arguments[0])), (/** @type {?} */ (arguments[1]))];
        /** @type {?} */
        const currentLocale = this.$intl.getLocale$().value;
        this.lastOutput = new Intl.NumberFormat(currentLocale, opts).format(value);
        return this.lastOutput;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.stop$.next();
    }
}
IntlNumberPipe.decorators = [
    { type: Pipe, args: [{
                name: 'intlNumber',
                pure: false,
            },] }
];
/** @nocollapse */
IntlNumberPipe.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IntlService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxIntlModule {
    /**
     * @param {?} options
     * @return {?}
     */
    static forRoot(options) {
        return {
            ngModule: NgxIntlModule,
            providers: [
                (/** @type {?} */ ({ provide: NGX_INTL_DEFAULT_LOCALE, useValue: options.defaultLocale })),
            ]
        };
    }
}
NgxIntlModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IntlDatePipe, IntlNumberPipe],
                imports: [],
                exports: [IntlDatePipe, IntlNumberPipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IntlService, NgxIntlModule, NGX_INTL_DEFAULT_LOCALE as ɵa, IntlDatePipe as ɵb, IntlNumberPipe as ɵc };
//# sourceMappingURL=ngx-intl.js.map
