/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Pipe } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, skip } from 'rxjs/operators';
import { IntlService } from '../intl.service';
/**
 * @author Abdel El-medny
 *
 * Shows numbers based on the Intl API
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat
 */
export class IntlNumberPipe {
    /**
     * @param {?} changeDetectorRef
     * @param {?} $intl
     */
    constructor(changeDetectorRef, $intl) {
        this.changeDetectorRef = changeDetectorRef;
        this.$intl = $intl;
        this.lastOutput = null;
        this.lastInput = [null, null];
        this.stop$ = new Subject();
        // If the locale changes, we will take the last inputs we were given, will re-calc the output and trigger CD
        //
        this.$intl.getLocale$().pipe(takeUntil(this.stop$), skip(1))
            .subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            const [lastDate, lastOpts] = this.lastInput;
            this.lastOutput = new Intl.NumberFormat(locale, lastOpts).format(lastDate);
            this.changeDetectorRef.markForCheck();
        }));
    }
    /**
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    transform(value, opts) {
        // If the input hasn't changed, we will send back the last calculated value
        //
        if (this.lastInput.toString() === value.toString()) {
            return this.lastOutput;
        }
        // Storing this for later usage incase locale changes
        //
        this.lastInput = [(/** @type {?} */ (arguments[0])), (/** @type {?} */ (arguments[1]))];
        /** @type {?} */
        const currentLocale = this.$intl.getLocale$().value;
        this.lastOutput = new Intl.NumberFormat(currentLocale, opts).format(value);
        return this.lastOutput;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.stop$.next();
    }
}
IntlNumberPipe.decorators = [
    { type: Pipe, args: [{
                name: 'intlNumber',
                pure: false,
            },] }
];
/** @nocollapse */
IntlNumberPipe.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IntlService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    IntlNumberPipe.prototype.lastOutput;
    /**
     * @type {?}
     * @private
     */
    IntlNumberPipe.prototype.lastInput;
    /**
     * @type {?}
     * @private
     */
    IntlNumberPipe.prototype.stop$;
    /**
     * @type {?}
     * @private
     */
    IntlNumberPipe.prototype.changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    IntlNumberPipe.prototype.$intl;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50bC1udW1iZXIucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1pbnRsLyIsInNvdXJjZXMiOlsibGliL3BpcGVzL2ludGwtbnVtYmVyLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBYSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRWxGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7Ozs7O0FBYTlDLE1BQU0sT0FBTyxjQUFjOzs7OztJQVF6QixZQUNVLGlCQUFvQyxFQUNwQyxLQUFrQjtRQURsQixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLFVBQUssR0FBTCxLQUFLLENBQWE7UUFScEIsZUFBVSxHQUFXLElBQUksQ0FBQztRQUUxQixjQUFTLEdBQXVDLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTdELFVBQUssR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBTTVCLDRHQUE0RztRQUM1RyxFQUFFO1FBQ0YsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQzFCLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQ3JCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FDUjthQUNBLFNBQVM7Ozs7UUFBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO2tCQUNkLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTO1lBRTNDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFM0UsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3hDLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7O0lBRUQsU0FBUyxDQUFDLEtBQWEsRUFBRSxJQUErQjtRQUN0RCwyRUFBMkU7UUFDM0UsRUFBRTtRQUNGLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxLQUFLLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDbEQsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1NBQ3hCO1FBRUQscURBQXFEO1FBQ3JELEVBQUU7UUFDRixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsbUJBQUEsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFVLEVBQUUsbUJBQUEsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUE0QixDQUFDLENBQUM7O2NBRTlFLGFBQWEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDLEtBQUs7UUFFbkQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUzRSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQzs7OztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3BCLENBQUM7OztZQW5ERixJQUFJLFNBQUM7Z0JBQ0osSUFBSSxFQUFFLFlBQVk7Z0JBQ2xCLElBQUksRUFBRSxLQUFLO2FBQ1o7Ozs7WUFoQlEsaUJBQWlCO1lBSWpCLFdBQVc7Ozs7Ozs7SUFlbEIsb0NBQWtDOzs7OztJQUVsQyxtQ0FBcUU7Ozs7O0lBRXJFLCtCQUE4Qjs7Ozs7SUFHNUIsMkNBQTRDOzs7OztJQUM1QywrQkFBMEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgT25EZXN0cm95LCBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgc2tpcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEludGxTZXJ2aWNlIH0gZnJvbSAnLi4vaW50bC5zZXJ2aWNlJztcblxuLyoqXG4gKiBAYXV0aG9yIEFiZGVsIEVsLW1lZG55XG4gKlxuICogU2hvd3MgbnVtYmVycyBiYXNlZCBvbiB0aGUgSW50bCBBUElcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlckZvcm1hdFxuICovXG5AUGlwZSh7XG4gIG5hbWU6ICdpbnRsTnVtYmVyJyxcbiAgcHVyZTogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIEludGxOdW1iZXJQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSwgT25EZXN0cm95IHtcblxuICBwcml2YXRlIGxhc3RPdXRwdXQ6IHN0cmluZyA9IG51bGw7XG5cbiAgcHJpdmF0ZSBsYXN0SW5wdXQ6IFtudW1iZXIsIEludGwuTnVtYmVyRm9ybWF0T3B0aW9uc10gPSBbbnVsbCwgbnVsbF07XG5cbiAgcHJpdmF0ZSBzdG9wJCA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSAkaW50bDogSW50bFNlcnZpY2UsXG4gICkge1xuICAgIC8vIElmIHRoZSBsb2NhbGUgY2hhbmdlcywgd2Ugd2lsbCB0YWtlIHRoZSBsYXN0IGlucHV0cyB3ZSB3ZXJlIGdpdmVuLCB3aWxsIHJlLWNhbGMgdGhlIG91dHB1dCBhbmQgdHJpZ2dlciBDRFxuICAgIC8vXG4gICAgdGhpcy4kaW50bC5nZXRMb2NhbGUkKCkucGlwZShcbiAgICAgIHRha2VVbnRpbCh0aGlzLnN0b3AkKSxcbiAgICAgIHNraXAoMSksXG4gICAgKVxuICAgIC5zdWJzY3JpYmUoKGxvY2FsZSkgPT4ge1xuICAgICAgY29uc3QgW2xhc3REYXRlLCBsYXN0T3B0c10gPSB0aGlzLmxhc3RJbnB1dDtcblxuICAgICAgdGhpcy5sYXN0T3V0cHV0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgbGFzdE9wdHMpLmZvcm1hdChsYXN0RGF0ZSk7XG5cbiAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICB0cmFuc2Zvcm0odmFsdWU6IG51bWJlciwgb3B0cz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgLy8gSWYgdGhlIGlucHV0IGhhc24ndCBjaGFuZ2VkLCB3ZSB3aWxsIHNlbmQgYmFjayB0aGUgbGFzdCBjYWxjdWxhdGVkIHZhbHVlXG4gICAgLy9cbiAgICBpZiAodGhpcy5sYXN0SW5wdXQudG9TdHJpbmcoKSA9PT0gdmFsdWUudG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIHRoaXMubGFzdE91dHB1dDtcbiAgICB9XG5cbiAgICAvLyBTdG9yaW5nIHRoaXMgZm9yIGxhdGVyIHVzYWdlIGluY2FzZSBsb2NhbGUgY2hhbmdlc1xuICAgIC8vXG4gICAgdGhpcy5sYXN0SW5wdXQgPSBbYXJndW1lbnRzWzBdIGFzIG51bWJlciwgYXJndW1lbnRzWzFdIGFzIEludGwuTnVtYmVyRm9ybWF0T3B0aW9uc107XG5cbiAgICBjb25zdCBjdXJyZW50TG9jYWxlID0gdGhpcy4kaW50bC5nZXRMb2NhbGUkKCkudmFsdWU7XG5cbiAgICB0aGlzLmxhc3RPdXRwdXQgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY3VycmVudExvY2FsZSwgb3B0cykuZm9ybWF0KHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzLmxhc3RPdXRwdXQ7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3AkLm5leHQoKTtcbiAgfVxufVxuIl19