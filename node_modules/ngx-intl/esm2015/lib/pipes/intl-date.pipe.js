/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectorRef, Pipe } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, skip } from 'rxjs/operators';
import { IntlService } from '../intl.service';
/**
 * @author Abdel El-medny
 *
 * Shows dates based on the Intl API
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
 */
export class IntlDatePipe {
    /**
     * @param {?} changeDetectorRef
     * @param {?} $internationalisation
     */
    constructor(changeDetectorRef, $internationalisation) {
        this.changeDetectorRef = changeDetectorRef;
        this.$internationalisation = $internationalisation;
        this.lastOutput = null;
        this.lastInput = [null, null];
        this.stop$ = new Subject();
        // If the locale changes, we will take the last inputs we were given, will re-calc the output and trigger CD
        //
        this.$internationalisation.getLocale$().pipe(takeUntil(this.stop$), skip(1))
            .subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        (locale) => {
            const [lastValue, lastOpts] = this.lastInput;
            /** @type {?} */
            const dateObject = (lastValue && typeof lastValue === 'string') ? new Date((/** @type {?} */ (lastValue))) : (/** @type {?} */ (lastValue));
            this.lastOutput = new Intl.DateTimeFormat(locale, lastOpts).format(dateObject);
            this.changeDetectorRef.markForCheck();
        }));
    }
    /**
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    transform(value, opts) {
        // If the input hasn't changed, we will send back the last calculated value
        //
        if (this.lastInput.toString() === value.toString()) {
            return this.lastOutput;
        }
        // Storing this for later usage incase locale changes
        //
        this.lastInput = [(/** @type {?} */ (arguments[0])), (/** @type {?} */ (arguments[1]))];
        /** @type {?} */
        const currentLocale = this.$internationalisation.getLocale$().value;
        /** @type {?} */
        const dateObject = typeof value === 'string' ? new Date((/** @type {?} */ (value))) : (/** @type {?} */ (value));
        this.lastOutput = new Intl.DateTimeFormat(currentLocale, opts).format(dateObject);
        return this.lastOutput;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.stop$.next();
    }
}
IntlDatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'intlDate',
                pure: false,
            },] }
];
/** @nocollapse */
IntlDatePipe.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IntlService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.lastOutput;
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.lastInput;
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.stop$;
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.$internationalisation;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50bC1kYXRlLnBpcGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtaW50bC8iLCJzb3VyY2VzIjpbImxpYi9waXBlcy9pbnRsLWRhdGUucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLElBQUksRUFBNEIsTUFBTSxlQUFlLENBQUM7QUFFbEYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7Ozs7Ozs7QUFhOUMsTUFBTSxPQUFPLFlBQVk7Ozs7O0lBUXZCLFlBQ1UsaUJBQW9DLEVBQ3BDLHFCQUFrQztRQURsQyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBYTtRQVJwQyxlQUFVLEdBQVcsSUFBSSxDQUFDO1FBRTFCLGNBQVMsR0FBOEMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFcEUsVUFBSyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7UUFNNUIsNEdBQTRHO1FBQzVHLEVBQUU7UUFDRixJQUFJLENBQUMscUJBQXFCLENBQUMsVUFBVSxFQUFFLENBQUMsSUFBSSxDQUMxQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUNyQixJQUFJLENBQUMsQ0FBQyxDQUFDLENBQ1I7YUFDQSxTQUFTOzs7O1FBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRTtrQkFDZCxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUzs7a0JBRXRDLFVBQVUsR0FBRyxDQUFDLFNBQVMsSUFBSSxPQUFPLFNBQVMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsbUJBQUEsU0FBUyxFQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQUEsU0FBUyxFQUFRO1lBRW5ILElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFL0UsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3hDLENBQUMsRUFBQyxDQUFDO0lBQ0wsQ0FBQzs7Ozs7O0lBRUQsU0FBUyxDQUFDLEtBQWtCLEVBQUUsSUFBaUM7UUFDN0QsMkVBQTJFO1FBQzNFLEVBQUU7UUFDRixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEtBQUssS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ2xELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztTQUN4QjtRQUVELHFEQUFxRDtRQUNyRCxFQUFFO1FBQ0YsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLG1CQUFBLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBZSxFQUFFLG1CQUFBLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBOEIsQ0FBQyxDQUFDOztjQUVyRixhQUFhLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxDQUFDLEtBQUs7O2NBRTdELFVBQVUsR0FBRyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLG1CQUFBLEtBQUssRUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFBLEtBQUssRUFBUTtRQUV4RixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRWxGLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN6QixDQUFDOzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDcEIsQ0FBQzs7O1lBdkRGLElBQUksU0FBQztnQkFDSixJQUFJLEVBQUUsVUFBVTtnQkFDaEIsSUFBSSxFQUFFLEtBQUs7YUFDWjs7OztZQWhCUSxpQkFBaUI7WUFJakIsV0FBVzs7Ozs7OztJQWVsQixrQ0FBa0M7Ozs7O0lBRWxDLGlDQUE0RTs7Ozs7SUFFNUUsNkJBQThCOzs7OztJQUc1Qix5Q0FBNEM7Ozs7O0lBQzVDLDZDQUEwQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBQaXBlLCBQaXBlVHJhbnNmb3JtLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzRXF1YWwgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCBza2lwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSW50bFNlcnZpY2UgfSBmcm9tICcuLi9pbnRsLnNlcnZpY2UnO1xuXG4vKipcbiAqIEBhdXRob3IgQWJkZWwgRWwtbWVkbnlcbiAqXG4gKiBTaG93cyBkYXRlcyBiYXNlZCBvbiB0aGUgSW50bCBBUElcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gKi9cbkBQaXBlKHtcbiAgbmFtZTogJ2ludGxEYXRlJyxcbiAgcHVyZTogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIEludGxEYXRlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0sIE9uRGVzdHJveSB7XG5cbiAgcHJpdmF0ZSBsYXN0T3V0cHV0OiBzdHJpbmcgPSBudWxsO1xuXG4gIHByaXZhdGUgbGFzdElucHV0OiBbRGF0ZXxzdHJpbmcsIEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zXSA9IFtudWxsLCBudWxsXTtcblxuICBwcml2YXRlIHN0b3AkID0gbmV3IFN1YmplY3QoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlICRpbnRlcm5hdGlvbmFsaXNhdGlvbjogSW50bFNlcnZpY2UsXG4gICkge1xuICAgIC8vIElmIHRoZSBsb2NhbGUgY2hhbmdlcywgd2Ugd2lsbCB0YWtlIHRoZSBsYXN0IGlucHV0cyB3ZSB3ZXJlIGdpdmVuLCB3aWxsIHJlLWNhbGMgdGhlIG91dHB1dCBhbmQgdHJpZ2dlciBDRFxuICAgIC8vXG4gICAgdGhpcy4kaW50ZXJuYXRpb25hbGlzYXRpb24uZ2V0TG9jYWxlJCgpLnBpcGUoXG4gICAgICB0YWtlVW50aWwodGhpcy5zdG9wJCksXG4gICAgICBza2lwKDEpLFxuICAgIClcbiAgICAuc3Vic2NyaWJlKChsb2NhbGUpID0+IHtcbiAgICAgIGNvbnN0IFtsYXN0VmFsdWUsIGxhc3RPcHRzXSA9IHRoaXMubGFzdElucHV0O1xuXG4gICAgICBjb25zdCBkYXRlT2JqZWN0ID0gKGxhc3RWYWx1ZSAmJiB0eXBlb2YgbGFzdFZhbHVlID09PSAnc3RyaW5nJykgPyBuZXcgRGF0ZShsYXN0VmFsdWUgYXMgc3RyaW5nKSA6IGxhc3RWYWx1ZSBhcyBEYXRlO1xuXG4gICAgICB0aGlzLmxhc3RPdXRwdXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIGxhc3RPcHRzKS5mb3JtYXQoZGF0ZU9iamVjdCk7XG5cbiAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICB0cmFuc2Zvcm0odmFsdWU6IERhdGV8c3RyaW5nLCBvcHRzPzogSW50bC5EYXRlVGltZUZvcm1hdE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIC8vIElmIHRoZSBpbnB1dCBoYXNuJ3QgY2hhbmdlZCwgd2Ugd2lsbCBzZW5kIGJhY2sgdGhlIGxhc3QgY2FsY3VsYXRlZCB2YWx1ZVxuICAgIC8vXG4gICAgaWYgKHRoaXMubGFzdElucHV0LnRvU3RyaW5nKCkgPT09IHZhbHVlLnRvU3RyaW5nKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhc3RPdXRwdXQ7XG4gICAgfVxuXG4gICAgLy8gU3RvcmluZyB0aGlzIGZvciBsYXRlciB1c2FnZSBpbmNhc2UgbG9jYWxlIGNoYW5nZXNcbiAgICAvL1xuICAgIHRoaXMubGFzdElucHV0ID0gW2FyZ3VtZW50c1swXSBhcyBEYXRlfHN0cmluZywgYXJndW1lbnRzWzFdIGFzIEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zXTtcblxuICAgIGNvbnN0IGN1cnJlbnRMb2NhbGUgPSB0aGlzLiRpbnRlcm5hdGlvbmFsaXNhdGlvbi5nZXRMb2NhbGUkKCkudmFsdWU7XG5cbiAgICBjb25zdCBkYXRlT2JqZWN0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG5ldyBEYXRlKHZhbHVlIGFzIHN0cmluZykgOiB2YWx1ZSBhcyBEYXRlO1xuXG4gICAgdGhpcy5sYXN0T3V0cHV0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY3VycmVudExvY2FsZSwgb3B0cykuZm9ybWF0KGRhdGVPYmplY3QpO1xuXG4gICAgcmV0dXJuIHRoaXMubGFzdE91dHB1dDtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3RvcCQubmV4dCgpO1xuICB9XG59XG4iXX0=