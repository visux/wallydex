/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectorRef, Pipe } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, skip } from 'rxjs/operators';
import { IntlService } from '../intl.service';
/**
 * @author Abdel El-medny
 *
 * Shows dates based on the Intl API
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
 */
var IntlDatePipe = /** @class */ (function () {
    function IntlDatePipe(changeDetectorRef, $internationalisation) {
        var _this = this;
        this.changeDetectorRef = changeDetectorRef;
        this.$internationalisation = $internationalisation;
        this.lastOutput = null;
        this.lastInput = [null, null];
        this.stop$ = new Subject();
        // If the locale changes, we will take the last inputs we were given, will re-calc the output and trigger CD
        //
        this.$internationalisation.getLocale$().pipe(takeUntil(this.stop$), skip(1))
            .subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        function (locale) {
            var _a = tslib_1.__read(_this.lastInput, 2), lastValue = _a[0], lastOpts = _a[1];
            /** @type {?} */
            var dateObject = (lastValue && typeof lastValue === 'string') ? new Date((/** @type {?} */ (lastValue))) : (/** @type {?} */ (lastValue));
            _this.lastOutput = new Intl.DateTimeFormat(locale, lastOpts).format(dateObject);
            _this.changeDetectorRef.markForCheck();
        }));
    }
    /**
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    IntlDatePipe.prototype.transform = /**
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    function (value, opts) {
        // If the input hasn't changed, we will send back the last calculated value
        //
        if (this.lastInput.toString() === value.toString()) {
            return this.lastOutput;
        }
        // Storing this for later usage incase locale changes
        //
        this.lastInput = [(/** @type {?} */ (arguments[0])), (/** @type {?} */ (arguments[1]))];
        /** @type {?} */
        var currentLocale = this.$internationalisation.getLocale$().value;
        /** @type {?} */
        var dateObject = typeof value === 'string' ? new Date((/** @type {?} */ (value))) : (/** @type {?} */ (value));
        this.lastOutput = new Intl.DateTimeFormat(currentLocale, opts).format(dateObject);
        return this.lastOutput;
    };
    /**
     * @return {?}
     */
    IntlDatePipe.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.stop$.next();
    };
    IntlDatePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'intlDate',
                    pure: false,
                },] }
    ];
    /** @nocollapse */
    IntlDatePipe.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: IntlService }
    ]; };
    return IntlDatePipe;
}());
export { IntlDatePipe };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.lastOutput;
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.lastInput;
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.stop$;
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.changeDetectorRef;
    /**
     * @type {?}
     * @private
     */
    IntlDatePipe.prototype.$internationalisation;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50bC1kYXRlLnBpcGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtaW50bC8iLCJzb3VyY2VzIjpbImxpYi9waXBlcy9pbnRsLWRhdGUucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQTRCLE1BQU0sZUFBZSxDQUFDO0FBRWxGLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7Ozs7O0FBUzlDO0lBWUUsc0JBQ1UsaUJBQW9DLEVBQ3BDLHFCQUFrQztRQUY1QyxpQkFtQkM7UUFsQlMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQywwQkFBcUIsR0FBckIscUJBQXFCLENBQWE7UUFScEMsZUFBVSxHQUFXLElBQUksQ0FBQztRQUUxQixjQUFTLEdBQThDLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRXBFLFVBQUssR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBTTVCLDRHQUE0RztRQUM1RyxFQUFFO1FBQ0YsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxDQUFDLElBQUksQ0FDMUMsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFDckIsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNSO2FBQ0EsU0FBUzs7OztRQUFDLFVBQUMsTUFBTTtZQUNWLElBQUEsdUNBQXNDLEVBQXJDLGlCQUFTLEVBQUUsZ0JBQTBCOztnQkFFdEMsVUFBVSxHQUFHLENBQUMsU0FBUyxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxtQkFBQSxTQUFTLEVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBQSxTQUFTLEVBQVE7WUFFbkgsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUUvRSxLQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDeEMsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDOzs7Ozs7SUFFRCxnQ0FBUzs7Ozs7SUFBVCxVQUFVLEtBQWtCLEVBQUUsSUFBaUM7UUFDN0QsMkVBQTJFO1FBQzNFLEVBQUU7UUFDRixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLEtBQUssS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ2xELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztTQUN4QjtRQUVELHFEQUFxRDtRQUNyRCxFQUFFO1FBQ0YsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLG1CQUFBLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBZSxFQUFFLG1CQUFBLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBOEIsQ0FBQyxDQUFDOztZQUVyRixhQUFhLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxDQUFDLEtBQUs7O1lBRTdELFVBQVUsR0FBRyxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLG1CQUFBLEtBQUssRUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFBLEtBQUssRUFBUTtRQUV4RixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRWxGLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN6QixDQUFDOzs7O0lBRUQsa0NBQVc7OztJQUFYO1FBQ0UsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNwQixDQUFDOztnQkF2REYsSUFBSSxTQUFDO29CQUNKLElBQUksRUFBRSxVQUFVO29CQUNoQixJQUFJLEVBQUUsS0FBSztpQkFDWjs7OztnQkFoQlEsaUJBQWlCO2dCQUlqQixXQUFXOztJQWlFcEIsbUJBQUM7Q0FBQSxBQXhERCxJQXdEQztTQXBEWSxZQUFZOzs7Ozs7SUFFdkIsa0NBQWtDOzs7OztJQUVsQyxpQ0FBNEU7Ozs7O0lBRTVFLDZCQUE4Qjs7Ozs7SUFHNUIseUNBQTRDOzs7OztJQUM1Qyw2Q0FBMEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgUGlwZSwgUGlwZVRyYW5zZm9ybSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc0VxdWFsIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgc2tpcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEludGxTZXJ2aWNlIH0gZnJvbSAnLi4vaW50bC5zZXJ2aWNlJztcblxuLyoqXG4gKiBAYXV0aG9yIEFiZGVsIEVsLW1lZG55XG4gKlxuICogU2hvd3MgZGF0ZXMgYmFzZWQgb24gdGhlIEludGwgQVBJXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICovXG5AUGlwZSh7XG4gIG5hbWU6ICdpbnRsRGF0ZScsXG4gIHB1cmU6IGZhbHNlLFxufSlcbmV4cG9ydCBjbGFzcyBJbnRsRGF0ZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtLCBPbkRlc3Ryb3kge1xuXG4gIHByaXZhdGUgbGFzdE91dHB1dDogc3RyaW5nID0gbnVsbDtcblxuICBwcml2YXRlIGxhc3RJbnB1dDogW0RhdGV8c3RyaW5nLCBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9uc10gPSBbbnVsbCwgbnVsbF07XG5cbiAgcHJpdmF0ZSBzdG9wJCA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSAkaW50ZXJuYXRpb25hbGlzYXRpb246IEludGxTZXJ2aWNlLFxuICApIHtcbiAgICAvLyBJZiB0aGUgbG9jYWxlIGNoYW5nZXMsIHdlIHdpbGwgdGFrZSB0aGUgbGFzdCBpbnB1dHMgd2Ugd2VyZSBnaXZlbiwgd2lsbCByZS1jYWxjIHRoZSBvdXRwdXQgYW5kIHRyaWdnZXIgQ0RcbiAgICAvL1xuICAgIHRoaXMuJGludGVybmF0aW9uYWxpc2F0aW9uLmdldExvY2FsZSQoKS5waXBlKFxuICAgICAgdGFrZVVudGlsKHRoaXMuc3RvcCQpLFxuICAgICAgc2tpcCgxKSxcbiAgICApXG4gICAgLnN1YnNjcmliZSgobG9jYWxlKSA9PiB7XG4gICAgICBjb25zdCBbbGFzdFZhbHVlLCBsYXN0T3B0c10gPSB0aGlzLmxhc3RJbnB1dDtcblxuICAgICAgY29uc3QgZGF0ZU9iamVjdCA9IChsYXN0VmFsdWUgJiYgdHlwZW9mIGxhc3RWYWx1ZSA9PT0gJ3N0cmluZycpID8gbmV3IERhdGUobGFzdFZhbHVlIGFzIHN0cmluZykgOiBsYXN0VmFsdWUgYXMgRGF0ZTtcblxuICAgICAgdGhpcy5sYXN0T3V0cHV0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBsYXN0T3B0cykuZm9ybWF0KGRhdGVPYmplY3QpO1xuXG4gICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZhbHVlOiBEYXRlfHN0cmluZywgb3B0cz86IEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zKTogc3RyaW5nIHtcbiAgICAvLyBJZiB0aGUgaW5wdXQgaGFzbid0IGNoYW5nZWQsIHdlIHdpbGwgc2VuZCBiYWNrIHRoZSBsYXN0IGNhbGN1bGF0ZWQgdmFsdWVcbiAgICAvL1xuICAgIGlmICh0aGlzLmxhc3RJbnB1dC50b1N0cmluZygpID09PSB2YWx1ZS50b1N0cmluZygpKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0T3V0cHV0O1xuICAgIH1cblxuICAgIC8vIFN0b3JpbmcgdGhpcyBmb3IgbGF0ZXIgdXNhZ2UgaW5jYXNlIGxvY2FsZSBjaGFuZ2VzXG4gICAgLy9cbiAgICB0aGlzLmxhc3RJbnB1dCA9IFthcmd1bWVudHNbMF0gYXMgRGF0ZXxzdHJpbmcsIGFyZ3VtZW50c1sxXSBhcyBJbnRsLkRhdGVUaW1lRm9ybWF0T3B0aW9uc107XG5cbiAgICBjb25zdCBjdXJyZW50TG9jYWxlID0gdGhpcy4kaW50ZXJuYXRpb25hbGlzYXRpb24uZ2V0TG9jYWxlJCgpLnZhbHVlO1xuXG4gICAgY29uc3QgZGF0ZU9iamVjdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBuZXcgRGF0ZSh2YWx1ZSBhcyBzdHJpbmcpIDogdmFsdWUgYXMgRGF0ZTtcblxuICAgIHRoaXMubGFzdE91dHB1dCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGN1cnJlbnRMb2NhbGUsIG9wdHMpLmZvcm1hdChkYXRlT2JqZWN0KTtcblxuICAgIHJldHVybiB0aGlzLmxhc3RPdXRwdXQ7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3AkLm5leHQoKTtcbiAgfVxufVxuIl19